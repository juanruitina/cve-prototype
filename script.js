// fetch json, store in variable data and log it

// query:
// https://ubuntu.com/security/cves.json?limit=100&offset=0&priority=high

fetch('data/data-4.json')
    .then(response => response.json())
    //.then(data => )
    .then(data => {
        console.log(data);

        let columns = ["ID", "Priority", "Summarised status", "Statuses", "Packages"];
             
        let descriptions = {
            "ignored": [],
            "not-affected": [],
            "deferred": []
        };

        let globalPackageList = [];
        let globalReleaseList = [];

        function loadTable(data, selectorPackage = "all", selectorRelease = "all") {
            const table = document.createElement('table');
            
            // add headers
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            columns.forEach(column => {
                const th = document.createElement('th');
                th.innerHTML = column;
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            table.appendChild(thead);

            // create tbody
            const tbody = document.createElement('tbody');

            data.cves.forEach(item => {
                // iterate over packages to check if package.name matches selectorPackage

                let packageMatch = false;
                let releaseMatch = false;

                if (selectorPackage != "all") {
                    for (const package of item.packages) {
                        if (package.name == selectorPackage) {
                            packageMatch = true;
                            break;
                        }
                    }
                }

                if (selectorRelease != "all") {
                    for (const package of item.packages) {
                        for (const status of package.statuses) {
                            if (status.release_codename == selectorRelease) {
                                releaseMatch = true;
                                break;
                            }
                        }
                    }
                }

                if ( (selectorPackage == "all" || packageMatch == true) && (selectorRelease == "all" || releaseMatch == true) ) {
                    // add table row
                    const row = document.createElement('tr');

                    // add heading
                    const a = document.createElement('a');
                    a.href = "https://ubuntu.com/security/" + item.id;
                    a.innerHTML = item.id;
                    const heading = document.createElement('th');
                    heading.appendChild(a);
                    row.appendChild(heading);

                    // add priority
                    const priority = document.createElement('td');
                    // capitalise priority
                    priority.innerHTML = item.priority.charAt(0).toUpperCase() + item.priority.slice(1);
                    row.appendChild(priority);

                    // process packages
                    let statusCounters = {
                        "total": 0,
                        "total-clean": 0,
                        "ignored-lower": 0
                    };

                    let packages = [];

                    // for every package
                    item.packages.forEach(package => {
                        // for every status
                        package.statuses.forEach(status => {
                            // console.log(status);

                            // exclude upstream packages
                            if (status.release_codename != "upstream" && (package.name == selectorPackage || selectorPackage == "all") && (status.release_codename == selectorRelease || selectorRelease == "all")) {
                                // add package to packages
                                if (packages.indexOf(package.name) == -1) {
                                    packages.push(package.name);
                                }

                                if (globalPackageList.indexOf(package.name) == -1) {
                                    globalPackageList.push(package.name);
                                }

                                if (globalReleaseList.indexOf(status.release_codename) == -1) {
                                    globalReleaseList.push(status.release_codename);
                                }

                                // add 1 to total
                                statusCounters.total++;

                                // add status to statusCounters
                                if (statusCounters[status.status]) {
                                    statusCounters[status.status]++;
                                } else {
                                    statusCounters[status.status] = 1;
                                }

                                if (status.status == "ignored") {
                                    if (descriptions.ignored.indexOf(status.description) == -1) {
                                        descriptions.ignored.push(status.description);
                                    }   
                                }

                                if (status.status == "not-affected") {
                                    if (descriptions["not-affected"].indexOf(status.description) == -1) {
                                        descriptions["not-affected"].push(status.description);
                                    }   
                                }

                                if (status.status == "deferred") {
                                    if (descriptions["deferred"].indexOf(status.description) == -1) {
                                        descriptions["deferred"].push(status.description);
                                    }   
                                }

                                // add 1 to ignored-lower if status is ignored and description is "out of standard support" or contains "superseded"
                                if (status.status == "ignored" && ( status.description.includes("out of standard support") || status.description.includes("end of standard support") || status.description.includes("end-of-life") ) ) {
                                    statusCounters["ignored-lower"]++;
                                }

                                if (status.status == "ignored" && ( status.description.includes("superseded") || status.description.includes("replaced") ) ) {
                                    statusCounters["ignored-lower"]++;
                                }
                            }
                        });
                    });

                    let fixed = statusCounters['released'];

                    (fixed) ? statusCounters["fixed"] = fixed : statusCounters["fixed"] = 0;

                    let vulnerable = (statusCounters['needed'] ?? 0) + (statusCounters['active'] ?? 0) + (statusCounters['pending'] ?? 0) + (statusCounters['deferred'] ?? 0);

                    (vulnerable) ? statusCounters["vulnerable"] = vulnerable : statusCounters["vulnerable"] = 0;

                    // exclude "does not exist", less problematic "ignored", and "not affected" from total count
                    statusCounters['total-clean'] = statusCounters['total'];

                    if (statusCounters['not-affected']) {
                        statusCounters['total-clean'] = statusCounters['total-clean'] - statusCounters['not-affected'];
                    }

                    if (statusCounters['DNE']) {
                        statusCounters['total-clean'] = statusCounters['total-clean'] - statusCounters['DNE'];
                    }

                    if (statusCounters['ignored-lower']) {
                        statusCounters['total-clean'] = statusCounters['total-clean'] - statusCounters['ignored-lower'];
                    }

                    // console.log(statusCounters);

                    // add summarised status
                    /* 
                    If status for all packages and versions is the same, excluding "does not exist" and "no data"
                        Fixed
                        Not affected
                        Vulnerable
                        Ignored
                        Needs evaluation
                    Else if all are fixed, excluding “not affected”
                        Fixed
                    Else if any is fixed
                        Some fixes available (x/total)
                    Else if any is vulnerable
                        Vulnerable
                    Else if any needs evaluation
                        Needs evaluation
                    */

                    // add status
                    let summarisedStatus = "";

                    if ( statusCounters["total-clean"] == statusCounters.fixed && statusCounters["total-clean"] > 0  ) {
                        summarisedStatus = "Fixed";
                    } else if ( statusCounters["total-clean"] == statusCounters.vulnerable && statusCounters["total-clean"] > 0 ) {
                        summarisedStatus = "Vulnerable";
                    } else if ( ( statusCounters["total-clean"] + statusCounters["not-affected"] == statusCounters["not-affected"] ) ) {
                        summarisedStatus = "Not affected";
                    } else if ( statusCounters.fixed > 0 ) {
                        summarisedStatus = "Some fixes available (" + statusCounters.fixed + "/" + statusCounters["total-clean"] + ")";
                    } else if ( statusCounters.vulnerable > 0 ) {
                        summarisedStatus = "Vulnerable";
                    } else if ( statusCounters["needs-triage"] > 0 ) {
                        summarisedStatus = "Needs evaluation";
                    } else if ( statusCounters["DNE"] > 0 ) {
                        summarisedStatus = "Not in release";
                    }

                    if ( summarisedStatus == "Vulnerable" ) {
                        summarisedStatus = `<img class="status-icon" src="icons/status-vulnerable.svg" alt="" /> ${summarisedStatus}`;
                    } else if ( summarisedStatus == "Fixed" || summarisedStatus == "Not affected" ) {
                        summarisedStatus = `<img class="status-icon" src="icons/status-fixed.svg" alt="" /> ${summarisedStatus}`;
                    // } else if ( summarisedStatus == "Needs evaluation" ) {
                    //     summarisedStatus = `<img class="status-icon" src="icons/status-needs-evaluation.svg" alt="" /> ${summarisedStatus}`;
                    }

                    const summarisedStatusElement = document.createElement('td');
                    summarisedStatusElement.classList.add('summarised-status');
                    summarisedStatusElement.innerHTML = summarisedStatus;
                    row.appendChild(summarisedStatusElement);

                    // add counters
                    const counters = document.createElement('td');

                    // counters.innerHTML = "Total: " + statusCounters.total + " Total (clean): " + statusCounters['total-clean'] + " Fixed: " + statusCounters.fixed + " Vulnerable: " + statusCounters.vulnerable;

                    // iterate over statusCounters
                    let countersHTML = "";

                    for (const [key, value] of Object.entries(statusCounters)) {
                        countersHTML += `${key}: ${value} `;
                        // add separator except for last
                        if (key != Object.keys(statusCounters).pop()) {
                            countersHTML += " | ";
                        }
                    }
                    
                    counters.innerHTML = countersHTML;
                    row.appendChild(counters);

                    // // add description
                    // const description = document.createElement('p');
                    // description.innerHTML = item.description;
                    // table.appendChild(description);

                    // add packages, comma separated
                    const packagesElement = document.createElement('td');
                    // limit packages to 5
                    if (packages.length > 5) {
                        packages = packages.slice(0, 5);
                        packages = packages.join(", ") + " and " + (item.packages.length - 5) + " more";
                    } else {
                        packages = packages.join(", ");
                    }
                    packagesElement.innerHTML = packages;
                    row.appendChild(packagesElement);
                    
                    // add row to table
                    tbody.appendChild(row);
                }
            });

            // add table to page
            table.appendChild(tbody);
            document.querySelector(".results").appendChild(table);
        };

        loadTable(data);

        // add selector with packages
        const selector = document.createElement('select');
        selector.classList.add('package-selector');
        selector.setAttribute('name', 'package-selector');
        selector.setAttribute('id', 'package-selector');
        
        // add option for all packages
        const optionAll = document.createElement('option');
        optionAll.setAttribute('value', 'all');
        optionAll.innerHTML = "All packages";

        selector.appendChild(optionAll);

        // add options for each package
        for (const package of globalPackageList) {
            const option = document.createElement('option');
            option.setAttribute('value', package);
            option.innerHTML = package;
            selector.appendChild(option);
        }

        // add selector with releases
        const selectorReleases = document.createElement('select');
        selectorReleases.classList.add('release-selector');
        selectorReleases.setAttribute('name', 'release-selector');
        selectorReleases.setAttribute('id', 'release-selector');

        // add option for all releases
        const optionAllReleases = document.createElement('option');
        optionAllReleases.setAttribute('value', 'all');
        optionAllReleases.innerHTML = "All releases";

        selectorReleases.appendChild(optionAllReleases);

        // add options for each release
        for (const release of globalReleaseList) {
            const option = document.createElement('option');
            option.setAttribute('value', release);
            option.innerHTML = release;
            selectorReleases.appendChild(option);
        }
        
        // add selector to page
        document.querySelector(".selectors").appendChild(selector);
        document.querySelector(".selectors").appendChild(selectorReleases);

        // on change, reload table
        selector.addEventListener('change', function() {
            // remove table
            document.querySelector(".results").innerHTML = "";

            loadTable(data, selector.value, selectorReleases.value);
        });

        selectorReleases.addEventListener('change', function() {
            // remove table
            document.querySelector(".results").innerHTML = "";

            loadTable(data, selector.value, selectorReleases.value);
        });

        // add descriptions in a list
        for (const [key, values] of Object.entries(descriptions)) {
            if (values.length > 0) {
                // add header
                const header = document.createElement('h2');
                header.innerHTML = `Descriptions for "${key}" packages`;
                document.querySelector("body").appendChild(header);

                const list = document.createElement('ul');
                
                for (const description of values) {
                    const item = document.createElement('li');
                    item.innerHTML = description;
                    list.appendChild(item);
                }

                // add element at end of page
                document.querySelector("body").appendChild(list);
            }
        }
    });