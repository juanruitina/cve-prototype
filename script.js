// fetch json, store in variable data and log it

// query:
// https://ubuntu.com/security/cves.json?limit=100&offset=0&priority=high

fetch('data/data-1.json')
    .then(response => response.json())
    //.then(data => )
    .then(data => {
        console.log(data);
        // create tbody
        const table = document.createElement('tbody');
        let ignoredDescriptions = [];

        data.cves.forEach(item => {
            // add table row
            const row = document.createElement('tr');

            // add heading
            const a = document.createElement('a');
            a.href = "https://ubuntu.com/security/" + item.id;
            a.innerHTML = item.id;
            const heading = document.createElement('th');
            heading.appendChild(a);
            row.appendChild(heading);

            // add priority
            const priority = document.createElement('td');
            // capitalise priority
            priority.innerHTML = item.priority.charAt(0).toUpperCase() + item.priority.slice(1);
            row.appendChild(priority);

            // process packages
            let statusCounters = {
                "total": 0,
                "total-clean": 0,
                "ignored-lower": 0
            };

            let packages = [];

            // for every package
            item.packages.forEach(package => {
                // for every status
                package.statuses.forEach(status => {
                    console.log(status);

                    // exclude upstream packages
                    if (status.release_codename != "upstream") {
                        // add package to packages
                        if (packages.indexOf(package.name) == -1) {
                            packages.push(package.name);
                        }

                        // add 1 to total
                        statusCounters.total++;

                        // add status to statusCounters
                        if (statusCounters[status.status]) {
                            statusCounters[status.status]++;
                        } else {
                            statusCounters[status.status] = 1;
                        }

                        if (status.status == "ignored") {
                            if (ignoredDescriptions.indexOf(status.description) == -1) {
                                ignoredDescriptions.push(status.description);
                            }   
                        }

                        // add 1 to ignored-lower if status is ignored and description is "out of standard support" or contains "superseded"
                        if (status.status == "ignored" && ( status.description.includes("out of standard support") || status.description.includes("end of standard support") || status.description.includes("end-of-life") ) ) {
                            statusCounters["ignored-lower"]++;
                        }

                        if (status.status == "ignored" && ( status.description.includes("superseded") || status.description.includes("replaced") ) ) {
                            statusCounters["ignored-lower"]++;
                        }
                    }
                });
            });

            let fixed = statusCounters['released'];

            (fixed) ? statusCounters["fixed"] = fixed : statusCounters["fixed"] = 0;

            let vulnerable = (statusCounters['needed'] ?? 0) + (statusCounters['active'] ?? 0) + (statusCounters['pending'] ?? 0) + (statusCounters['deferred'] ?? 0);

            (vulnerable) ? statusCounters["vulnerable"] = vulnerable : statusCounters["vulnerable"] = 0;

            // exclude "does not exist", less problematic "ignored", and "not affected" from total count
            statusCounters['total-clean'] = statusCounters['total'];

            if (statusCounters['not-affected']) {
                statusCounters['total-clean'] = statusCounters['total-clean'] - statusCounters['not-affected'];
            }

            if (statusCounters['DNE']) {
                statusCounters['total-clean'] = statusCounters['total-clean'] - statusCounters['DNE'];
            }

            if (statusCounters['ignored-lower']) {
                statusCounters['total-clean'] = statusCounters['total-clean'] - statusCounters['ignored-lower'];
            }

            console.log(statusCounters);

            // add summarised status
            /* 
            If status for all packages and versions is the same, excluding "does not exist" and "no data"
                Fixed
                Not affected
                Vulnerable
                Ignored
                Needs evaluation
            Else if all are fixed, excluding “not affected”
                Fixed
            Else if any is fixed
                Some fixes available (x/total)
            Else if any is vulnerable
                Vulnerable
            Else if any needs evaluation
                Needs evaluation
            */

            // add status
            let summarisedStatus = "";

            if ( statusCounters["total-clean"] == statusCounters.fixed && statusCounters["total-clean"] > 0  ) {
                summarisedStatus = "Fixed";
            } else if ( statusCounters["total-clean"] == statusCounters.vulnerable && statusCounters["total-clean"] > 0 ) {
                summarisedStatus = "Vulnerable";
            } else if ( ( statusCounters["total-clean"] + statusCounters["not-affected"] == statusCounters["not-affected"] ) ) {
                summarisedStatus = "Not affected";
            } else if ( statusCounters.fixed > 0 ) {
                summarisedStatus = "Some fixes available (" + statusCounters.fixed + "/" + statusCounters["total-clean"] + ")";
            } else if ( statusCounters.vulnerable > 0 ) {
                summarisedStatus = "Vulnerable";
            } else if ( statusCounters["needs-triage"] > 0 ) {
                summarisedStatus = "Needs evaluation";
            }

            if ( summarisedStatus == "Vulnerable" ) {
                summarisedStatus = `<img class="status-icon" src="icons/status-vulnerable.svg" alt="" /> ${summarisedStatus}`;
            } else if ( summarisedStatus == "Fixed" || summarisedStatus == "Not affected" ) {
                summarisedStatus = `<img class="status-icon" src="icons/status-fixed.svg" alt="" /> ${summarisedStatus}`;
            // } else if ( summarisedStatus == "Needs evaluation" ) {
            //     summarisedStatus = "";
            }

            const summarisedStatusElement = document.createElement('td');
            summarisedStatusElement.classList.add('summarised-status');
            summarisedStatusElement.innerHTML = summarisedStatus;
            row.appendChild(summarisedStatusElement);

            // add counters
            const counters = document.createElement('td');
            // counters.innerHTML = "Total: " + statusCounters.total + " Total (clean): " + statusCounters['total-clean'] + " Fixed: " + statusCounters.fixed + " Vulnerable: " + statusCounters.vulnerable;
            // iterate over statusCounters
            let countersHTML = "";
            for (const [key, value] of Object.entries(statusCounters)) {
                countersHTML += `${key}: ${value} `;
                // add separator except for last
                if (key != Object.keys(statusCounters).pop()) {
                    countersHTML += " | ";
                }
            }
            counters.innerHTML = countersHTML;
            row.appendChild(counters);

            // // add description
            // const description = document.createElement('p');
            // description.innerHTML = item.description;
            // table.appendChild(description);

            // add packages, comma separated
            const packagesElement = document.createElement('td');
            // limit packages to 5
            if (packages.length > 5) {
                packages = packages.slice(0, 5);
                packages = packages.join(", ") + " and " + (item.packages.length - 5) + " more";
            } else {
                packages = packages.join(", ");
            }
            packagesElement.innerHTML = packages;
            row.appendChild(packagesElement);
            
            // add row to table
            table.appendChild(row);            
        });

        // append the tbody to table
        document.querySelector(".results").appendChild(table);

        // add ignored descriptions in a list
        if (ignoredDescriptions.length > 0) {
            // add header
            const ignoredDescriptionsHeader = document.createElement('h2');
            ignoredDescriptionsHeader.innerHTML = "Ignored descriptions";
            document.querySelector("body").appendChild(ignoredDescriptionsHeader);

            const ignoredDescriptionsElement = document.createElement('ul');
            
            for (const description of ignoredDescriptions) {
                const descriptionElement = document.createElement('li');
                descriptionElement.innerHTML = description;
                ignoredDescriptionsElement.appendChild(descriptionElement);
            }

            // add element at end of page
            document.querySelector("body").appendChild(ignoredDescriptionsElement);
        }
    })
    