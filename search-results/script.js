// fetch json, store in variable data and log it

// query:
// https://ubuntu.com/security/cves.json?limit=100&offset=0&priority=high

fetch('../data/data-4.json')
    .then(response => response.json())
    //.then(data => )
    .then(data => {
        console.log(data);

        let columns = ["ID", "Priority", "Summarised status", "Statuses", "Packages", "Releases"];
        let columnsWidth = [10, 5, 10, 45, 15, 15];
             
        let descriptions = {
            "ignored-high": [],
            "ignored-low": [],
            "not-affected": [],
            "deferred": []
        };

        let globalPackageList = [];
        let globalReleaseList = [];

        function loadResults(data, selectorPackage = "all", selectorRelease = "all") {
            const resultsContainer = document.createElement('div');
            resultsContainer.classList.add('results-container');

            data.cves.forEach(item => {
                // iterate over packages to check if package.name matches selectorPackage

                let packageMatch = false;
                let releaseMatch = false;

                if (selectorPackage != "all") {
                    for (const package of item.packages) {
                        if (package.name == selectorPackage) {
                            packageMatch = true;
                            break;
                        }
                    }
                }

                if (selectorRelease != "all") {
                    for (const package of item.packages) {
                        for (const status of package.statuses) {
                            if (status.release_codename == selectorRelease) {
                                releaseMatch = true;
                                break;
                            }
                        }
                    }
                }

                if ( (selectorPackage == "all" || packageMatch == true) && (selectorRelease == "all" || releaseMatch == true) ) {
                    // add table row
                    const result = document.createElement('article');
                    result.classList.add('result');

                    // add heading
                    const a = document.createElement('a');
                    a.href = "https://ubuntu.com/security/" + item.id;
                    a.innerHTML = item.id;
                    const heading = document.createElement('h2');
                    heading.classList.add('p-heading--3');
                    heading.appendChild(a);
                    result.appendChild(heading);

                    // add priority
                    const priority = document.createElement('div');
                    priority.classList.add('priority');
                    

                    // capitalise priority
                    priority.innerHTML = `<i class="p-icon--${item.priority}-priority"></i> ` + item.priority.charAt(0).toUpperCase() + item.priority.slice(1) + " priority";
                    result.appendChild(priority);

                    // process packages
                    let statusCounters = {
                        "total": 0,
                        "fixable": 0,
                        "ignored": 0,
                        "ignored-high": 0,
                        "ignored-low": 0,
                        "needs-triage": 0,
                        "not-affected": 0,
                        "vulnerable": 0,
                        "fixed": 0,
                        "DNE": 0
                    };

                    let packages = [];
                    let releases = [];
                    let ignoredLow = [];
                    let ignoredHigh = [];

                    // for every package
                    item.packages.forEach(package => {
                        // for every status
                        package.statuses.forEach(status => {
                            // console.log(status);

                            // exclude upstream packages
                            if (status.release_codename != "upstream" && (package.name == selectorPackage || selectorPackage == "all") && (status.release_codename == selectorRelease || selectorRelease == "all")) {
                                // add package to packages
                                if (packages.indexOf(package.name) == -1) {
                                    packages.push(package.name);
                                }

                                if (releases.indexOf(status.release_codename) == -1) {
                                    releases.push(status.release_codename);
                                }

                                if (globalPackageList.indexOf(package.name) == -1) {
                                    globalPackageList.push(package.name);
                                }

                                if (globalReleaseList.indexOf(status.release_codename) == -1) {
                                    globalReleaseList.push(status.release_codename);
                                }

                                // add 1 to total
                                statusCounters.total++;

                                // add status to statusCounters
                                if (statusCounters[status.status]) {
                                    statusCounters[status.status]++;
                                } else {
                                    statusCounters[status.status] = 1;
                                }

                                if (status.status == "not-affected") {
                                    if (descriptions["not-affected"].indexOf(status.description) == -1) {
                                        descriptions["not-affected"].push(status.description);
                                    }
                                }

                                if (status.status == "deferred") {
                                    if (descriptions["deferred"].indexOf(status.description) == -1) {
                                        descriptions["deferred"].push(status.description);
                                    }
                                }

                                // add 1 to ignored-low if status is ignored and description is "out of standard support" or contains "superseded"
                                if (status.status == "ignored" ) {
                                    if ( status.description.includes("out of standard support") ||
                                    status.description.includes("end of standard support") ||
                                    status.description.includes("end-of-life") ||
                                    status.description.includes("end of ESM support") ||
                                    status.description.includes("superseded") ||
                                    status.description.includes("replaced") ) {
                                        statusCounters["ignored-low"]++;

                                        if (ignoredLow.indexOf(status.description) == -1) {
                                            ignoredLow.push(status.description);
                                        }  

                                        if (descriptions["ignored-low"].indexOf(status.description) == -1) {
                                            descriptions["ignored-low"].push(status.description);
                                        }  
                                    } else {
                                        statusCounters["ignored-high"]++;

                                        if (ignoredHigh.indexOf(status.description) == -1) {
                                            ignoredHigh.push(status.description);
                                        }  

                                        if (descriptions["ignored-high"].indexOf(status.description) == -1) {
                                            descriptions["ignored-high"].push(status.description);
                                        }  
                                    }
                                }
                            }
                        });
                    });

                    let fixed = statusCounters['released'];

                    (fixed) ? statusCounters["fixed"] = fixed : statusCounters["fixed"] = 0;

                    let vulnerable = (statusCounters['needed'] ?? 0) + (statusCounters['active'] ?? 0) + (statusCounters['pending'] ?? 0) + (statusCounters['deferred'] ?? 0);

                    (vulnerable) ? statusCounters["vulnerable"] = vulnerable : statusCounters["vulnerable"] = 0;

                    // exclude "does not exist", less problematic "ignored", and "not affected" from total count
                    statusCounters['fixable'] = statusCounters['total'];

                    if (statusCounters['not-affected']) {
                        statusCounters['fixable'] = statusCounters['fixable'] - statusCounters['not-affected'];
                    }

                    if (statusCounters['DNE']) {
                        statusCounters['fixable'] = statusCounters['fixable'] - statusCounters['DNE'];
                    }

                    if (statusCounters['ignored-low']) {
                        statusCounters['fixable'] = statusCounters['fixable'] - statusCounters['ignored-low'];
                    }

                    // console.log(statusCounters);

                    // add summarised status
                    /* 
                    If status for all packages and versions is the same, excluding "does not exist" and "no data"
                        Fixed
                        Not affected
                        Vulnerable
                        Ignored
                        Needs evaluation
                    Else if all are fixed, excluding “not affected”
                        Fixed
                    Else if any is fixed
                        Some fixes available (x/total)
                    Else if any is vulnerable
                        Vulnerable
                    Else if any needs evaluation
                        Needs evaluation
                    */

                    // add status
                    let summarisedStatus = "";

                    if ( statusCounters["fixable"] == statusCounters.fixed && statusCounters["fixable"] > 0  ) {
                        summarisedStatus = "Fixed";
                    } else if ( statusCounters["fixable"] == statusCounters.vulnerable && statusCounters["fixable"] > 0 ) {
                        summarisedStatus = "Vulnerable";
                    } else if ( ( statusCounters["fixable"] + statusCounters["not-affected"] == statusCounters["not-affected"] ) ) {
                        summarisedStatus = "Not affected";
                    } else if ( statusCounters.fixed > 0 ) {
                        summarisedStatus = `Some fixes <span class="muted">${statusCounters.fixed}/${statusCounters['fixable']}</span>`;
                    } else if ( statusCounters.vulnerable > 0 ) {
                        summarisedStatus = "Vulnerable";
                    } else if ( statusCounters["needs-triage"] > 0 ) {
                        summarisedStatus = "Needs evaluation";
                    } else if ( statusCounters["ignored"] > 0 ) {
                        summarisedStatus = "Ignored";
                    } else if ( statusCounters["DNE"] > 0 ) {
                        summarisedStatus = "Not in release";
                    }

                    if ( summarisedStatus == "Vulnerable" ) {
                        summarisedStatus = `<img class="status-icon" src="../icons/status-vulnerable.svg" alt="" /> ${summarisedStatus}`;
                    } else if ( summarisedStatus == "Fixed" || summarisedStatus == "Not affected" ) {
                        summarisedStatus = `<img class="status-icon" src="../icons/status-fixed.svg" alt="" /> ${summarisedStatus}`;
                    // } else if ( summarisedStatus == "Needs evaluation" ) {
                    //     summarisedStatus = `<img class="status-icon" src="../icons/status-needs-evaluation.svg" alt="" /> ${summarisedStatus}`;
                    }

                    let notification = document.querySelector(".notification--filters");

                    if (selectorPackage != "all" || selectorRelease != "all") {
                        notification.classList.remove("u-hide");

                        /* // add tooltip to summarised status
                        summarisedStatus += `<span style="margin-left: .25rem" class="p-tooltip--btm-right" role="tooltip"><i class="p-icon--information"></i><span class="p-tooltip__message" role="tooltip">Status based on your filters</span></span>`;

                        // add paragraph before table
                        const paragraph = document.createElement('p');
                        paragraph.classList.add('p-notification__response');
                        paragraph.innerHTML = `Status based on your filters. <a href="https://ubuntu.com/security/notices">View all security notices</a>.`; */
                    } else {
                        notification.classList.add("u-hide");
                    }

                    const summarisedStatusElement = document.createElement('div');
                    summarisedStatusElement.classList.add('summarised-status');
                    summarisedStatusElement.innerHTML = summarisedStatus;
                    result.appendChild(summarisedStatusElement);

                

                    // add description
                    const description = document.createElement('p');
                    description.classList.add('description');
                    if (item.description) {
                        description.innerHTML = item.description;
                    } else {
                        description.innerHTML = "[No description available]";
                        description.classList.add('muted');
                    }
                    result.appendChild(description);

                    // add packages, comma separated
                    const packagesElement = document.createElement('div');
                    packagesElement.classList.add('packages');

                    // add package header
                    const packageHeader = document.createElement('h3');
                    packageHeader.innerHTML = "Related packages";
                    packageHeader.classList.add('p-text--small-caps');
                    packagesElement.appendChild(packageHeader);

                    // limit packages to 5

                    let allPackagesNames = [];
                    for (let i = 0; i < item.packages.length; i++) {
                        allPackagesNames.push(item.packages[i].name);
                    }

                    let packageString = "";

                    let matchingPackageNames = packages;
                    let packageCounter = 0;

                    if ( matchingPackageNames.length == allPackagesNames.length ) {
                        matchingPackageNames = [];
                    }

                    if ( matchingPackageNames.length > 0 ) {
                        packageString += "<strong>" + matchingPackageNames.join(", ") + "</strong>, ";
                        packageCounter = matchingPackageNames.length;
                    }

                    console.log(matchingPackageNames);

                    // for every package in allPackagesNames
                    for (let i = 0; i < allPackagesNames.length; i++) {
                        // if package is not in matchingPackageNames
                        if ( !matchingPackageNames.includes(allPackagesNames[i]) ) {
                            // add package to packageString
                            packageString += allPackagesNames[i] + ", ";
                            packageCounter++;
                        }

                        if ( packageCounter > 5 ) {
                            break;
                        }
                    }

                    if ( item.packages.length - 5 > 0 ) {
                        packageString += "and " + (item.packages.length - 5) + " more";
                    }
                        
                    packagesElement.innerHTML += `<p class="p-text--small">${packageString}</p>`;
                    result.appendChild(packagesElement);

                    /* // add releases, comma separated
                    const releasesElement = document.createElement('td');
                    releases = releases.join(", ");
                    releasesElement.innerHTML = releases;
                    result.appendChild(releasesElement); */
                    
                    // add row to table
                    resultsContainer.appendChild(result);
                }
            });

            // add table to page
            document.querySelector(".results").appendChild(resultsContainer);
        };

        loadResults(data);

        // add selector with packages
        const selector = document.createElement('select');
        selector.classList.add('package-selector');
        selector.setAttribute('name', 'package-selector');
        selector.setAttribute('id', 'package-selector');

        // add options for each package
        for (const package of globalPackageList) {
            const option = document.createElement('option');
            option.setAttribute('value', package);
            option.innerHTML = package;
            selector.appendChild(option);
        }

        // sort options alphabetically
        const options = Array.from(selector.querySelectorAll('option'));
        options.sort((a, b) => a.innerHTML.localeCompare(b.innerHTML));
        options.forEach(option => selector.appendChild(option));

        // add option for all packages at the beginning
        const optionAll = document.createElement('option');
        optionAll.setAttribute('value', 'all');
        optionAll.innerHTML = "All packages";
        selector.insertBefore(optionAll, selector.firstChild);
        // select all
        selector.value = "all";

        // add selector with releases
        const selectorReleases = document.createElement('select');
        selectorReleases.classList.add('release-selector');
        selectorReleases.setAttribute('name', 'release-selector');
        selectorReleases.setAttribute('id', 'release-selector');

        // add option for all releases
        const optionAllReleases = document.createElement('option');
        optionAllReleases.setAttribute('value', 'all');
        optionAllReleases.innerHTML = "All releases";

        selectorReleases.appendChild(optionAllReleases);

        // add options for each release
        for (const release of globalReleaseList) {
            const option = document.createElement('option');
            option.setAttribute('value', release);
            option.innerHTML = release;
            selectorReleases.appendChild(option);
        }
        
        // add selector to page
        document.querySelector(".selectors").appendChild(selector);
        document.querySelector(".selectors").appendChild(selectorReleases);

        // on change, reload results
        selector.addEventListener('change', function() {
            // remove results
            document.querySelector(".results .results-container").remove();

            loadResults(data, selector.value, selectorReleases.value);
        });

        selectorReleases.addEventListener('change', function() {
            // remove results
            document.querySelector(".results .results-container").remove();

            loadResults(data, selector.value, selectorReleases.value);
        });           
    });